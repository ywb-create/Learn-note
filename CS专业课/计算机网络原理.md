# 计算机网络原理

## 1.概述

### 1.网络模型

#### 1.ISO/OSI模型

  网络层 传输层 会话层  表现层 应用层

| ISO/OSI模型 | 各层功能                     |
| ----------- | ---------------------------- |
| 物理层      | 透明传输比特流               |
| 数据链路层  | 提供介质访问和链路管理       |
| 网络层      | IP选址及路由选择             |
| 传输层      | 建立、管理和维护端到端的连接 |
| 会话层      | 建立、管理和维护会话         |
| 表现层      | 数据格式转换、数据加密       |
| 应用层      | 为应用程序提供服务           |

#### 2.TCP/IP模型

| TCP/IP模型 | 对应协议                                  |
| ---------- | ----------------------------------------- |
| 网络接口层 | PPP                                       |
| 网络层     | IP、ICMP、ARP、IGMP、RARP                 |
| 传输层     | **TCP**、**UDP**                          |
| 应用层     | **DNS**、**HTTP**、**HTTPS**、Telnet、FTP |

#### 3.五层模型

| 五层模型   | 对应协议                                  | 功能                                                         |
| ---------- | ----------------------------------------- | ------------------------------------------------------------ |
| 物理层     | -                                         | 透明传输比特流                                               |
| 数据链路层 | PPP                                       | 将网络层的IP数据报封装成帧，并在两个相邻节点进行无差错的传输数据 |
| 网络层     | IP、ICMP、ARP、IGMP、RARP                 | 确定数据交换双方的IP地址，并将传输层的数据分组传输           |
| 传输层     | **TCP**、**UDP**                          | 确定数据交换双方的进程，并提供通用单位数据传输服务           |
| 应用层     | **DNS**、**HTTP**、**HTTPS**、Telnet、FTP | 通过应用进程间的交互来完成特定的网络应用                     |

### 2.数据封装与解封装过程

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810090215572.png" alt="image-20200810090215572" style="zoom:50%;" />

##### 封装过程：

​	首先一个用户在发给电脑一个请求，先传给应用层应用将数据处理完，之后交给传出加好TCP或者UDP的报头，传给应用层网络层在添加一层IP的报头，再交给数据链路层添加mac的头部和尾部，最后送到物理链路层转为比特流进行传出，这可以玩吗可以比作寄快递或者发请求的过程，这就是封装过程。

##### 解封装过程：

​	解封装与封装过程相反，封装是从应用层到物理层一层层加报头，解封装是在物理层到应用层的过程一层层去报头，我们可以想象层收到快递的过程，或者读取文件的过程。

### 3.分层的原因

​	网路进行分层是为了简化网络设计时的复杂性，通信协议采用分层的结构，各层协议相互独立且能高效的协调工作，更加灵活，当一层发生变化时，只要接口不发生改变就不会影响其它层

## 2.数据链路层

### 1.概述

​	数据链路层首部为mac帧，这一层解决三个基本问题：封装成帧，透明传输和差错控制

##### 封装成帧

​	封装成帧就是在一段数据的前后分别添加手部和尾部，然后构成一个数据帧，在数据发送时如A->B，若B未收到帧首或者帧尾，那此帧作废

##### 透明传输

​	**发送方**：若数据部分出现帧开始符或者帧结束符，会在前方加转义字符在发送，防止接收方接收错误

​	**接收方**：当识别出字节填充或者字符填充，接收端的数据链路层在将数据送往网络层前删除插入的转义字符

##### 差错控制

​	差错控制是由循环冗余检验—CRC差错检测技术实现

### 2.PPP协议

​	PPP协议:点对点协议(Point to Point Protocol)

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810092640707.png" alt="image-20200810092640707" style="zoom:33%;" />

### 3.CSMA/CD

​	CSMA/CD  ：载波侦听多路访问/冲突检测，是广播型信道中采用一种随机访问技术的竞争型访问方法，具有多目标地址的特点。

​	数据传输特点：先听后发	边听边发	冲突停止	随机延时后发	

## 3.网络层

### 1.IP协议

​	在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**（网际协议），因此分组也叫 **IP 数据报** ，简称**数据报**。

#### 1.IP地址

​	IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式。

| 地址类型           | 网络号 | 主机号 |
| ------------------ | ------ | ------ |
| A类地址（0-127）   | 8位    | 位     |
| B类地址（128-191） | 16位   | 16位   |
| C类地址（192-223） | 位     | 8位    |

​	在同一网络中，不同主机网络号相同，主机号不同

**网络地址**：代表一个网络的所有IP地址（表示：网络号相同，主机号全0）

**广播地址**：专门用于向一个网络中每一台主机发送数据（表示：网络号形同，主机号全为1）

**回送地址**：代表本主机	127.0.0.1----->127.255.255.254

#### 2.子网划分

​	将一个网络地址划分为多个子网使用，此时的IP地址分为  网络号  子网号	主机号

借用规则：向主机号最少借一位，最多借到主机号剩两位

子网掩码：子网掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，值为0的比特留给主机号，如C类地址192.168.1.1分成**两个子网**,则子网掩码的值为:（11111111.11111111.11111111.1000000）  —>255.255.255.128

#### 3.无分类编址CIDR

​	消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。它可以将好几个IP网络结合在一起，使用一种无类别的域际路由选择算法，使它们合并成一条路由从而较少路由表中的路由条目减轻Internet路由器的负担。

CIDR结构：网络前缀+网络后缀。 如128.110.35.7/20  （20代表网络前缀位数）

地址掩码：网络前缀的值全为1，后缀全为0

### 2.ARP协议

​	ARP(Address Resolution Protocol)协议：地址解析协议，**可以通过IP地址解析出MAC地址**

ARP协议过程：

​	（1）当主机PC0想向下一跳（默认网关）发送IP分组时，就先在其**ARP高速缓存**中查看有无下一跳的地址

​	（2）有则查出目标的MAC地址写入到MAC帧中，然后发送此硬件地址

​	（3）无则进入ARP请求（广播）和应答（单播）阶段

### 3.ICMP协议

​	ICMP（Internet Control Message Protocol）协议：网际控制报文协议。在信息传输过程中出现某种错误时，设备会向心愿返回一条ICMP信息，告诉它发生的错误类型。

​	ping命令使用了ICMP回送请求和回送应答报文，是应用层直接使用ICMP的例子，未经过TCP/UDP协议

### 4.路由

##### 1.静态路由

​	静态路由是最原始的配置路由方式，纯手工，易管理，但是耗时，不能反映网络拓扑，当网络拓扑发生变化时，管理员必须手动更改路由表，有点事简介，消耗资源少，安全，静态路由是单向的

##### 2.默认路由

​	当路由器在路由表中找不到目标网络时，路由器会将请求转发到默认接口路由，掩码长度为0，表明此路由匹配全部IP地址

##### 3.动态路由和RIP协议

​	动态路由是指路由器能够自动的建立自己的路由表，并且能够实际情况的变化适时的进行调整

​	**RIP协议：**动态路由协议，可以维护路由信息，建立路由表，决定最佳路径。RIP 协议周期性（30s）更新，最大跳数为15跳，16跳为不可达，每经过一个路由器跳数+1，跳数最小的为最佳路由

​			优点：自动适应网络状态的变化

​			缺点：占用宽带，安全性不如静态路由

## 4.传输层

​	**传输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。传输层主要使用以下两种协议:

1. TCP（Transmission Control Protocol）：传输控制协议，提供**面向连接**的，**可靠的**数据传输服务。
2. UDP（User Datagram Protocol）:用户数据报协议 ，提供无连接的，尽最大努力的数据传输服务。

### 1.UDP协议

##### 首部报文：

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810112825929.png" alt="image-20200810112825929" style="zoom:50%;" />

##### 主要特点：

（1）UDP是无连接的,在发送数据前不需要建立连接

（2）UDP不保证数据的可靠交付，是不可靠的协议

（3）UDP面向报文传输

（4）支持一对一，一对多，多对多的通信方式

（5）UDP首部开销小，只有八个字节

**附加**：

​	UDP是不可靠的协议，可在应用层加入握手、重传等机制实现可靠的UDP通信

### 2.TCP协议

#### 1.首部报文

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810113625373.png" alt="image-20200810113625373" style="zoom:50%;" />

TCP首部各字段解释：

​	源端口：发送方端口号

​	目的端口：接收方端口号

​	序列号：发送方数据的起始位置

​	确认号：确认接收的数据位置

​	首部长度：表示TCP报文段扩充到了多少字节

​	标志比特：

​		URG：置1时表示紧急指针有效，此数据为加急数据，优先传输

​		ACK：置1时表示确认号有效

​		PSH：置1时表示此数据接收方需要优先处理

​		RST：置1时表示重建连接

​		SYN：置1时表示建立连接

​		FIN：置1时表示断开连接

​	窗口大小：表示作为接收端的TCP缓冲大小，要求发送端的TCP 发送缓存置为相同大小

#### 2.可靠传输

​	**自动重传请求**（Automatic Repeat-reQuest，ARQ），ARQ协议分为**停止等待ARQ协议**和**连续ARQ协议**。它通过使用==确认==和==超时重传==两个机制，就可以在不可靠的网络上实现可靠的通信。

##### 1.停止等待ARQ协议

​	停止等待协议的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810152939963.png" alt="image-20200810152939963" style="zoom:50%;" />

###### 超时重传的时间选择

​	TCP没发送一个报文段，就对这个报文段设置一次计数器，只要这个计时器的重传时间还没有确认，则重传这一报文段。超时重传时间要略大于RTT(平均往返时间)	

​	停止等待ARQ协议实现简单 但是**信道利用率低，等待时间长**。

##### 连续ARQ协议

​	连续 ARQ 协议可提高信道利用率。发送方维持一个**发送窗口**，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用**累计确认**，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

**缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

#### 3.流量控制

​	如果发送方把数据发送的过快，接收方可能会来不及接收，这样就会造成数据的丢失，所谓流量控制就是让发送发的发送速率不要太快，以便于让接收方来得及接收数据（接收方控制发送方）。流量控制是利用**滑动窗口**实现的，具体原理就是用接收方设置TCP首部报文的窗口大小来控制发送方的窗口大小。发送的发送窗口不可以大于接收方的接收窗口大小。如果接收方没有足够的缓存来接收数据，发送方就会收到一个零窗口的通知。此时发送方停止发送。并且**定时发送一个窗口探测报文来探测接收方的接收能力**。

#### 4.拥塞控制

##### 1.出现拥塞条件

​	对资源需求的总和  >  可用资源   （比如带宽为50Mb，但是所有计算机的资源请求加起来大于50Mb）

##### 2.与流量控制的不同

​	拥塞控制是一个全局性的过程，涉及所有的主机，路由器以及降低网络传输性能有关的因素。流量控制只是一个发送端到接收端点对点通信量的控制，而拥塞控制是整个网络全局性的过程。TCP的传输速率需要流量控制和拥塞控制共同调整发送方的敞口，所以最终的发送窗口上限值为MAX(rwnd,cwnd)。【流量控制是接收方的流量控制，而拥塞避免是发送方的流量控制】

##### 3.拥塞控制算法

###### 慢启动

​		cwnd----->发送方的窗口大小		ssthresh----->慢开始门限

​	当发送方与接收方建立TCP 连接时，cwnd置为1，之后收到ACK后，将cwnd * 2（1，2，4，8，16），若cwnd >= ssthresh后，开始拥塞避免算法。

###### 拥塞避免

​	让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1。当拥塞发生时，ssthresh置为当前cwnd的一半，cwnd置为1，重新启动慢开始算法

###### 快重传和快恢复

​	如果一连串收到三个或者三个以上的重复ACK，就非常可能只是一个报文段丢失了，于是就可以只重传丢失的报文段，无需等待超时定时器的溢出，这就是快重传算法。一旦开始快重传算法，则判断不是拥塞，不启动慢启动算法，而是使用快恢复算法：将ssthresh和cwnd都调整为当前cwnd的一半。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810174016566.png" alt="image-20200810174016566" style="zoom:50%;" />

#### 5.三次握手与四次挥手

##### 三次握手

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810180230221.png" alt="image-20200810180230221" style="zoom:50%;" />

###### 三次握手的原因：

​	三次握手最主要的目的**就是双方确认自己与对方的发送与接收是正常的**。如果是两次握手的话，可能会产生服务端与一个早已失效的SYN报文段建立连接从而造成资源浪费。如果是四次握手，SYN与ACK分开发送，则会浪费资源，因为握手时不需要传输其他数据，服务端的SYN与ACK可以同时发送。

##### 四次挥手

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810180256686.png" alt="image-20200810180256686" style="zoom:50%;" />

###### 四次挥手的原因：

​	四次挥手是为了让通信双方在**双方的数据传送全都结束后再释放连接，在第一个FIN报文发出后，另一方可能还有未发送完的数据无法直接释放连接，所以FIN和ACK要分开发送，这也是为什么不能三次挥手的原因。

###### 等待2MSL的原因：

​	1MSL是一个段在网络上的最大生存时间，2MSL正好是数据往返的时间，若2MSL的时间内服务器还没重发FIN，则推测服务端已经接收到ACK,可以释放连接。如果不等待，并且服务器未收到客户端的ACK，则服务器会重发FIN报文段，造成永远不会释放连接的结果。【**为了防止最后一个ACK丢失**】			

### 3.TCP和UDP的区别及应用场景

| TCP                                          | UDP                                                          |
| -------------------------------------------- | ------------------------------------------------------------ |
| 面向连接                                     | 无连接                                                       |
| 可靠，有流量控制和拥塞控制                   | 不可靠，可能丢失数据，无其他控制手段                         |
| 面向字节流                                   | 面向数据报                                                   |
| 点对点通信                                   | 广播，可一对多，多对多                                       |
| 消耗资源多（首部20字节，最大到60），较慢     | 消耗资源少（首部为8字节），较快                              |
| 主要应用在文件传输，邮件接发，远程登录等场景 | 主要应用于视频/语音通话等对数据确定性不高的等场景下，还有广播通信 |

## 5.应用层

​	应用层的任务是**通过应用进程间的交互来完成特定网络应用**。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。

### 1.DNS协议

​	DNS协议，域名解析协议，在DNS中由域名服务器完成**域名向IP地址间的转换**。【 **UDP/TCP+53端口** 】

##### 1.域名服务器：

​	根域名服务器：指的是一个www.baidu.com.   的com后省略的.

​	顶级域名服务器：管理该顶级域名服务器下注册的所有二级域名（com、net、org）

​	权限域名服务器：负责一个区域的域名服务器（baidu.com）

​	本地域名服务器：当一个主机发送DNS查询请求时，这个查询请求就会发送给本地域名服务器。

##### 2.域名解析过程

​	DNS两种查询流程：递归查询和迭代查询

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810201249066.png" alt="image-20200810201249066" style="zoom:50%;" />

##### 3.真实DNS解析流程：

​	主机与本地域名服务器递归查询，本地域名服务器迭代查询。真实DNS实现上一般都采用高速缓存技术，各级域名服务器缓存一段时间查询结果。



<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810202919897.png" alt="image-20200810202919897" style="zoom:33%;" />

```java
查询过程：
1、主机m.abc.com先向本地服务器dns.xyz.com进行递归查询。
2、本地服务器采用迭代查询。它先向一个根域名服务器查询。
3、根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。
4、本地域名服务器向顶级域名服务器dns.com进行查询。
5、顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.abc.com的IP地址。
6、本地域名服务器向权限域名服务器dns.abc.com进行查询。
7、权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址。
8、本地域名服务器最后把查询结果告诉m.xyz.com。
```

​	**说明：**当访问一个url时如 www.github.com，会先查询浏览器的DNS缓存**，未命中会查询**OS中的缓存**（在OS的**hosts文件中），如果还未命中则会**查询路由器缓存**（即本地域名服务器）

##### 4.基于的传输层协议

​	DNS协议大多使用的为UDP协议，因为UDP不用三次握手，对于DNS服务器的负载较低,在出现以下情况时会使用TCP协议：（1）响应报文大于512字节，此时UDP仅返回前512字节的内容，并设置报文首部为截断位，就客户收到响应后，会使用TCP重新发送原来的请求。（2）若一次查询的名字很多，则可能直接使用TCP。（3）DNS区域传输时使用TCP协议

##### 5.输入URL后的过程

​	1.浏览器经过DNS查出IP地址（DNS缓存  host文件  路由器缓存）

​	2.建立TCP连接

​	3.发送HTTP请求（HTTP->TCP->IP->ARP）

​	4.返回HTTP报文

​	5.浏览器解析渲染

### 2.HTTP协议

​	HTTP(Hyper Text Transfer Protocol)，超文本传输协议【 **TCP + 80端口** 】

#### 1.首部报文

##### 请求报文：

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810205914665.png" alt="image-20200810205914665" style="zoom:50%;" />

请求行：

（1）请求方法

| 请求方法 | 解释                                                      |
| -------- | --------------------------------------------------------- |
| GET      | 对资源进行请求                                            |
| POST     | 进行数据提交                                              |
| PUT      | 向指定资源上传最新内容                                    |
| DELETE   | 请求服务器删除url中所标示的资源                           |
| HEAD     | 像GET，但是只发送请求头，可以用来查询某页面的状态，效率高 |
| TRACE    | 回显服务器收到的请求，主要用于测试和诊断                  |
| CONNECT  | HTTP1.1中将连接改为管道方式的代理服务器                   |
| OPTIONS  | 可查看服务器的性能                                        |

###### 1.GET和POST的区别

- GET不安全，在传输过程中，数据被放在URL中，POST放在Request body中，不可见
- GET传送数据的长度受到URL 限制
- GET支持的字符集为ASSII，不如POST大
- GET是发一次请求，执行效率更高，POST发送两次请求，先发送Header，等服务器返回100时再发送data



（2）URL：<协议>://<域名>:<端口>/请求路径	

###### 2.URI和URL

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。（**是URI的子集**）



（3）版本：HTTP协议的版本	

###### 3.http 1.0和1.1的区别

- 在HTTP/1.0中，默认使用的是**短连接，每次请求都要重新建立一次连接(TCP三次握手四次挥手，开销大)**。HTTP 1.1起，默认使用**长连接** ,默认开启Connection： keep-alive。**在发生一次请求后用于传输HTTP数据的TCP连接不会关闭，再次访问时可以继续使用，如果客户端长时间无响应，则服务端会发送心跳包来确认客户端是否在线** 。HTTP/1.1的持续连接**有非流水线方式和流水线方式。**流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
- **错误状态响应码** :在HTTP1.1中新增了24个错误状态响应码
- 在HTTP1.1中有了**更多可供选择的缓存头**来控制缓存策略。
- HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分。**优化了带宽及网络连接的使用，且支持了断点续传**

###### 4.http 1.x和2.0的区别

- 1.x中的解析基于文本，2.0的**基于二进制**，2.0会更加健壮
- 2.0服务端可以向客户端**主动推送资源**
- 1.x中的header中带有大量信息，每次都要重复发送，在2.0中**压缩了头部信息**，避免了header的重复传输
- 2.0新增了**多路复用**，可以在一个连接中处理多个请求。因为2.0基于二进制，二进制帧每个请求头部会标识自己属于哪一个TCP流，所以这些帧是可以交错传输。

##### 响应报文：

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200810210009076.png" alt="image-20200810210009076" style="zoom:50%;" />

状态行：

（1）版本协议：同上

（2）状态码

| 状态码 | 解释                                           |
| ------ | ---------------------------------------------- |
| 1xx    | 临时响应，请求已接受，需要继续处理             |
| 2xx    | 代表已经成功接收请求                           |
| 3xx    | 需要客户端附加操作才能完成请求（常用于重定位） |
| 4xx    | 客户端错误                                     |
| 5xx    | 服务端错误                                     |

###### 5.常见状态码：

​	404：服务器无法找到客户端要请求的资源

​	200：请求成功

​	500：服务器错误

​	400：bad request 请求报文中存在语法错误

​	403：服务器拒绝此次访问

​	503：服务器超负载或者停机维护，无法处理该请求

（3）原因短语

#### 2.HTTP特点

​	HTTP 是一种不保存状态，即无状态（stateless）协议。**HTTP 协议自身不对请求和响应之间的通信状态进行保存**。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200717165818338.png" alt="image-20200717165818338" style="zoom:50%;" />

​	HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能,于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。

###### 6.Cookie的作用和与Session的区别

​	**Cookie 一般用来保存用户信息** ，如首次登陆网站时网站会记录Cookie信息，在用户第二次访问时自动填入

​	Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。**Session 的主要作用就是通过服务端记录用户的状态**，服务端给特定的用户创建特定的 Session 之后就可以**标识这个用户并且跟踪这个用户**。

​	区别：Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

######7.客户端禁用Cookie的解决方案

​	最常用的就是利用 **URL 重写**把 Session ID 直接附加在URL路径的后面。

### 3.HTTPS协议

​	HTTPS协议是在HTTP的基础上增加了SSL层通过传输加密和身份认证保证传输过程中的安全性。【 **TCP+443端口**  】 

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200718172041112.png" alt="image-20200718172041112" style="zoom:50%;" />

​	通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。

#### 1.HTTPS加密过程

​	HTTPS使用对称加密（不安全）和非对称加密（复杂，效率低）的混合加密方式。

##### 1.非对称加密传输密匙

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200718172536378.png" alt="image-20200718172536378" style="zoom:50%;" />

##### 2.对称加密传输数据

​	在以上第四步加密报文生成密匙，第五步服务端解密拿到密匙后，双方之后使用密匙加密数据进行数据传输。

#### 2.HTTP和HTTPS的区别

1.**端口** ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

2.**安全性和资源消耗：** HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。

3.HTTPS需要到CA机构申请证书，需要一定花销

4.HTTPS可以防止运营商劫持


