## 数据库原理与MySql

### 一：数据库基本原理

#### 1.事务

##### 1.定义

​	事务是访问并操作各种数据项的一个数据库操作序列,这些操作序列要不全执行,要不全部执行

##### 2.引入

```
Transactions are not a law of nature; they were created with a purpose, namely to simplify the programming model for applications accessing a database. By using transactions, the application is free to ignore certain potential error scenarios and concurrency issues, because the database takes care of them instead (we call these safety guarantees).
```

​	事务不是自然法则;创建它们的目的是为了**简化访问数据库的应用程序的编程模型**。通过使用事务，应用程序可以忽略某些潜在的错误场景和并发性问题，因为数据库会处理它们(我们称之为安全保证)。

##### 3.特点

​	原子性（Atomicity）：事务是不可分割的最小单位，事务的操作序列要不全执行要不全不执行

​	一致性（Consistency）：事务必须从一个一致性状态转到另一个一致性状态（保证**数据库所有约束的正确执行**）

​	隔离性（Isolation）：一个事务的执行不能被另一个事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的

​	持久性（Durability）：一个事务一旦提交，它对数据的改变就是永久性的

##### 4.AutoCommit

​	事务默认为自动提交，只要不显式的开启事务，那么每个操作都会被当成一个事务

#### 2.并发一致性问题

​	在并发环境下，事务的隔离性很难保证，会出现很多并发一致性问题

##### 1.丢失修改

​	T1和T2两个事务都对一个数据进行修改，T1先修改，之后T2修改，此时T2会覆盖T1的修改

##### 2.读脏数据

​	T1写入数据还未提交，此时T2读取了T1还未提交的数据，T1在T2读取后回滚事务。T2此时读到的为脏数据

##### 3.不可重复读

​	T1读数据，T2写并提交事务，T1第二次读，出现两次读取的数据不一致问题。

##### 4.幻读

​	T1读取到的数据为（1-n），此时T2插入了一条数据，T1在读取时发现数据为（1-n+1）。

#### 3.封锁

​	 封锁是实现并发控制的一个非常重要的技术。所谓封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。

##### 1.封锁粒度

​	Mysql提供了两种锁，表锁和行锁。

​	锁的数据量越小，粒度越小，并发性越高，但开销变大（锁的各种操作消耗资源）。因此在选择封锁粒度时，需要在锁开销和并发程度上做一个权衡

##### 2.封锁类型

- 读写锁
  - 互斥锁（X锁）：加X锁后其他事务不能对所锁数据进行操作	【写锁】
  - 共享锁（S锁）：加S锁后其他事务也可对所锁数据加S锁          【读锁】
- 意向锁：在读写锁的基础上引入了IS和IX锁，IS和IX为表锁。
  - 一个事务在加S锁前要先获得IS或者更强的锁
  - 一个事务在加X锁前，要先获得IX锁

##### 3.封锁协议

​	 封锁协议是在运用X锁和S锁这两种基本封锁，对数据对象加锁时进行一些规则的约定，例如应何时申请X锁或S锁、持锁时间、何时释放等。

###### 1.三级封锁协议

（1）一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。								 【解决丢失修改】

（2）二级封锁协议：在一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，**读完后即可释放S锁**。【解决读脏数据】

（3）三级封锁协议：在二级封锁协议上加上读取数据R之前必须先对其加S锁，**直到事务结束才释放**。		【解决不可重复读】

###### 2.两段锁协议

​	两段锁协议是指所有的事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一个阶段是获得封锁。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是释放封锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。简单说就是加锁和解锁分两次进行，且只有加锁**完全结束后**才可解锁。	

​	两段锁协议保证并行事务串行化。																													  【解读幻读问题。】

​	MySql的InnoDB引擎采用了两段锁协议，根据隔离级别在需要的时候自动加锁。

#### 4.隔离级别

- 未提交读：事务的修改，即使未提交，对其它事务也可见。**写数据时加上X锁，直到事务结束， 读的时候不加锁。** 
- 提交读：一个事务只能读取已经提交的事务所做的修改。**写数据的时候加上X锁，直到事务结束，读的时候加上S锁，读完数据立刻释放**
- 可重复读：保证在同一事务中多次读取的数据是一致的。**写数据的时候加上X锁， 直到事务结束，读数据的时候加S锁，直到事务结束释放**
- 可串行化：强制事务串行执行。**严格有序执行，事务不能并发执行 **

| 隔离级别 | 丢失修改 | 脏读 | 不可重复读 | 幻读 |
| -------- | -------- | ---- | ---------- | ---- |
| 未提交读 | X        | ✓    | ✓          | ✓    |
| 提交读   | X        | X    | ✓          | ✓    |
| 可重复读 | X        | X    | X          | ✓    |
| 可串行化 | X        | X    | X          | X    |

​	Mysql默认使用的隔离级别为可重复读，在大型互联网项目中，对数据的一致性要求不高时，可以将隔离级别改为提交读，提高并发。

#### 5.MVCC

​	MVCC（多版本并发控制）是MySql数据库InnoDB引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读两种隔离级别在**读数据时不需要的加锁操作**。（未提交读要求低，无需使用MVCC，可串行化需要对每条操作加锁，MVCC无法实现），在于提高数据库高并发场景下的吞吐性能 。

##### 1.MVCC具体实现

​	MVCC由版本链+Read View实现

​	版本链：在MySql表中会有两个隐藏的列，分别为t_id（存储对记录修改的事务的版本号）和roll_pointer（指向这个索引的上一个版本的位置）

​	Read View：是一个存储还未提交的事务的列表

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200813215855178.png" alt="image-20200813215855178" style="zoom:50%;" />	

​	在上面的示例中，如果此时T1启动，未提交，则Read View中为  [ 60 ]  ，此时另一个事务T3  select id为1的name值，查到的版本号为60，发现60存在于Read View中，则需要根据roll_pointer向下查，查到50时发现不在Read View中，则返回版本号为50的数据name=1。此时T1提交，T2启动,若此时隔离级别为提交读，Read  View中为 [ 70 ]，T3第二次select id为1的name值时可以查到版本号60的数据name=2（**隔离级别为提交读时会重新生成Read View**）；若此时的隔离级别为可重复读，Read view中仍为 [ 60  ]，T3第二次select id为1的name值时则只可查到版本号50的数据name=1（**隔离级别为可重复读时则会复用之间的Read View**）。 

##### 2.快照读和当前读

​	**快照读**：基于 MVCC 和 undo log 实现，适用于简单 select语句。读取的是记录数据的可见版本（可能是过期的数据），不用加锁【乐观锁】。

​	**当前读**：基于行锁和间隙锁实现，适用于 insert，update，delete， select ... for update（读加X锁）， select ... lock in share mode（读加S锁）语句，以及加锁了的 select 语句。**更新数据时，都是先读后写，而这个读，就是当前读**，读取数据时，读取该条数据已经提交的最新的事务，若当前读取的数据在另一个事务中更新还未提交时，则阻塞等待。【悲观锁】

#### 6.Next-Key Lock

##### 1.间隙锁

​	间隙锁（Gap Lock）是Innodb在**可重复读**的隔离级别下为了解决幻读问题时引入的锁机制。**间隙锁锁定一个范围，但不包括记录本身**。幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。

​	主要通过两个方面实现：（1）防止间隙内有新数据被插入	（2）防止已存在的数据，更新成间隙内的数据

​	在使用间隙锁时检索条件必须有索引，不然MySQL会全表扫描，锁住整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加

##### 2.Next-Key Lock

​	Next-Key Lock由行锁和间隙锁组成，**锁定一个范围，并且锁定记录本身**。MySql中InnoDB对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

##### 3.例子

​	比如在可重复读的隔离级别下，有如下一张表：

| id（主键） | age（二级索引） |
| ---------- | --------------- |
| 1          | 2               |
| 3          | 4               |
| 5          | 6               |
| 7          | 8               |

​	事务A：select  * from news where age=4 for update ;

​	间隙锁：此时检索条件age=4，向左取得最靠近的值2作为左区间，向右取得最靠近的6作为右区间，因此，间隙锁锁定的区间为（2，4），（4，6），即记录（id=1,number=2）和记录（id=3,number=4）之间间隙会被锁定，记录（id=3,number=4）和记录（id=5,number=6）之间间隙被锁定。间隙间不可插入数据。

​	Next-Key Lock：同间隙锁操作，同时会新增age=4的记录加行锁。

##### 4.RR下的问题

（1）在RR下，由于间隙锁不互斥，引发死锁的概率较高

（2）在RR下，未命中索引可能会被锁表，而RC只锁行

#### 7.范式

​	第一范式：数据库中的每一列都是不可分割的原子数据项

​	第二范式：表中的所有属性完全依赖于主键

​	第三范式：去除表中的传递依赖（如{学号}->{姓名，年龄，所属学院，学院地点}	存在{学号}->{所属学院}->{学院地点}的传递依赖）

### 二：MySQL

#### 1.索引

##### 1.定义

​	索引是一种用于快速查询和检索数据的数据结构。索引类似于书前面的目录，帮助我们快读找到想要查阅的章节。常见的索引有B树，B+树和Hash表。

##### 2.常见索引

###### 1.B树（B-tree）

（1）介绍

​	B树又名多路搜索树，是一开始针对机械磁盘而设计的，因为机械磁盘的磁头跳转消耗的时间比较多，为了减少跳转的次数，所以设计了B-Tree。B-tree利用了磁盘块的特性进行构建树。每个磁盘块一个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。B-tree巧妙利用了**磁盘预读原理**（操作系统都是按页的大小进行读取的，页大小通常为 4 kb，磁盘每次读取都会预读，**即使是读取一个字节，也会将一个页的数据读进内存**，这样就避免了多次 IO），将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。

（2）结构：

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200814162424500.png" alt="image-20200814162424500" style="zoom:50%;" />

（3）特点：

- 所有的叶子结点都出现在同一层中。
- 结点中存放（关键字、数据）和指针两部分，指针数=关键字数+1。（图中3=2+1）
- 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据。
- 其搜索性能等价于在关键字（key）全集内做一次二分查找

###### 2.B+树

​	B+树是B树的一个变种，是MySQL索引的底层数据结构

（1）结构：

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200814163650578.png" alt="image-20200814163650578" style="zoom:50%;" />

（2）特点：

- B+树只在叶子节点中存储数据，非叶子节点中只存储关键字key，所以在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快
- 所有叶子节点有一条引用链指向与他相邻的叶子节点，串成了一个链表，此链表正好是有序的，方便区间查找。
- 关键字和指针数量相同

（3）存储：

​	索引文件很大，一般存储在硬盘中，无法一次将全部索引加载到内存当中。B+树在设计时巧妙的根据计算机操作系统的局部性原理，将一个节点的大小设为等于一个页，在查询时磁盘预读会正好将一个节点的所有数据读进内存。并且索引文件根节点常驻内存，大大减少了查询次数。

###### 3.Hash

​	哈希索引（hash index）基于哈希表。对于每一行数据，都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。对于hash相同的，采用链表的方式解决冲突。类似于hashmap。因为索引的结构是十分紧凑的，所以hash索引的查询很快。**时间复杂度为O(1)**

##### 3.对比

###### 1.B树和B+树间的对比

- B+树的叶子节点被链表串起后数据是有序的，对于范围查找来说，只需要遍历链表，更有利于MySQL的区间查询。
- B+树的非叶子节点只存关键字，对于与B树来说，每个节点可以存储更多关键字，使得树更加矮胖。
- B+树的查询相对来说比较稳定，它只能在叶子节点中命中数据。而B树可能在非叶子节点命中数据，所以B树的时间复杂度最好时为O（1），最差为O(logn),B+树恒为O（logn）。

###### 2.Hash与B+树的对比

​	Hash索引的时间复杂度为O(1)，单个查询速度很快，但是**不支持顺序和范围查询**

###### 3.多路搜索树与二叉树的对比

​	在时间复杂度都为O(logn)的条件下，相对于传统的二叉树（AVL树，红黑树），多路搜索树的出度更高，使得树更加矮胖，**查询次数更少，查询速度会更快**。而且红黑树或者AVL树在逻辑上很近的节点（父子）物理上可能很远，**无法利用局部性远离进行磁盘预读**，IO效率比较差。

##### 4.索引类型

- 主键索引：数据表的主键列使用的就是主键索引，一张数据表有只能有一个主键，并且主键不能为null，不能重复。
- 唯一索引 ：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一
- 单值索引：一个索引中只包含单个列
- 组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
- 覆盖索引：要查询的数据正好是索引列

##### 5.创建规则

- 小表不建，大表建，外键建，列中的重复元素多不建
- 写操作频繁的列不建，频繁的更新会使得索引更新维护导致资源消耗
- 索引字段要尽量小，字段越小越小页中索引数量越多，树越矮

#### 2.索引分析与优化

##### 1.Explain分析

​	使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200814212852641.png" alt="image-20200814212852641" style="zoom:50%;" />

- id：表的读取顺序
  - id相同，执行顺序由上至下 
  - id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
- type：显示的是查询使用了哪种类型，从好到差依次是system > const > eq_ref > ref > range > index > all
  - system 表只有一行记录（等于系统表），这是const类型的特列
  - const 表示通过索引一次就找到了
  - eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
  - ref 非唯一性索引扫描，返回匹配某个单独值的所有行
  - range 范围查询
  - index 使用索引，遍历索引树（索引文件，从索引中读取）
  - all 遍历全表以找到匹配的行 （遍历数据文件，从硬盘读取）

- key：实际使用的索引，如果为NULL，则没有使用索引。

- key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，**长度越短越好**。

- rows：估算出找到所需记录需要的行数，**数值越小越好**

- Extra：额外信息，出现Using filesort和Using temporary需要优化。

  - Using filesort：没有按照表中的索引顺序进行读取。可能由order by自居的字段顺序和索引简历顺序不同导致

  - Using temporary：使用了用临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于order by和group by
  - Using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错

##### 2.索引失效

- 最佳左前缀法则：如果是查询时用组合索引，不遵守此法则，会导致索引失效
- 在索引列中做计算，函数，类型转换时失效
- 在使用!=、 <>、is null, is not null时会导致索引失效
- 查询字符串不加单引号会导致索引失效
- or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效
- 做模糊查询时（like）%在前会导致索引失效

##### 3.索引优化

（1）使用组合索引进行查询，要遵循最左前缀法则，即查询从索引的最左列开始

```sql
--创建的联合索引为（name,money,test）,此时mysql创建的索引为三个：（name）（name,money）（name,money,test），对应的key_len分别为23，46，51

--根据最佳左前缀法则的查询结果,使用到了索引，且索引的key_len为51，三个索引列全部使用到了为（name,money,test）
mysql>  explain select * from test where name='1' and money='10' and test=1 ;
+----+-----------------------+----------------+---------+-------------+------+----------------------+
| id | type | possible_keys  | key            | key_len | ref         | rows | Extra                |
+----+-----------------------+----------------+---------+-------------+------+----------------------+
|  1 | ref  | name_sex_money | name_money_test | 51      | const,const |    2 | Using index condition|
+----+-----------------------+----------------+---------+-------------+------+----------------------+
1 row in set, 2 warnings (0.00 sec)

--不符合最佳左前缀查询
--情况1：此时只用到了（name）一个索引列，key_len为23
mysql> explain select * from test where name='1' and test=10;
+----+-------------+---------+----------------+---------+-------+------+---------+------------------------+
| id | type | possible_keys  | key            | key_len | ref   | rows | filtered| Extra                  |
+----+-------------+---------+----------------+---------+-------+------+---------+------------------------+
|  1 | ref  | name_sex_money | name_money_test | 23      | const |    3 |    10.00| Using index condition  |
+----+-------------+---------+----------------+---------+-------+------+---------+------------------------+
1 row in set, 2 warnings (0.00 sec)

--情况2：查询时跳过第一个索引列，索引失效
mysql> explain select * from test where money='10' and test = 100;
+----+------+---------------+------+---------+------+------+-------------+
| id | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+------+---------------+------+---------+------+------+-------------+
|  1 | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where |
+----+------+---------------+------+---------+------+------+-------------+
1 row in set, 1 warning (0.00 sec)

--情况3：查询时使用范围查询,索引在第二列范围查询之后失效，此时用到了两个索引列（name,money），key_len为46
mysql> explain select * from test where name='1' and money>'10' and test=1 ;
+----+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
| id | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                 |
+----+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
|  1 | range | name_money_test | name_money_test | 46      | NULL |    3 |    10.00 | Using index condition |
+----+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
--原因：name_money_test索引在索引文件中是有序的，首先是根据name排序，然后是money，最后为test，首先索引找name，找到后在name相等的条件下，money必然是有序的。之后找到所有money>'10'之后，test就无法保证有序了，可能会出现（100，10），（1000，5）的情况。

```

（2）order by尽量在索引列上完成排序操作，遵循索引的最佳左前缀法则。order by有两种排序方式，一是使用索引进行排序，二是使用filesort。使用索引时性能更好。在使用order by时要**同升同降**。（group by与order by类似，分组前需要排序）

​	Order By满足两种情况使用index：

​		1、Order By 语句使用索引最佳左前缀												 【	只可以进行覆盖索引 】

​		2、使用where子句与Order By子句条件组合满足索引最佳左前缀	【   可select *					】

```sql
--注意：只有Order By时不要select *，只查询所需要的字段

--测试select *
--只有Order By时select *	【filesort】
mysql> explain select * from test order by name,money,test;
+----+------+---------------+------+---------+------+------+----------+----------------+
| id | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+------+---------------+------+---------+------+------+----------+----------------+
|  1 | ALL  | NULL          | NULL | NULL    | NULL |   12 |   100.00 | Using filesort |
+----+------+---------------+------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
--只有Order By时进行覆盖索引【index】
mysql> explain select name,money,test from test order by name,money,test;
+----+-------------+---------+------------------+---------+------+------+----------+----------------+
| id | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra          |
+----+-------------+---------+------------------+---------+------+------+----------+----------------+
|  1 | index | NULL          | name_money_test  | 51      | NULL |   12 |   100.00 | Using index    |
+----+-------------+---------+------------------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)


--测试最佳左前缀
--在order by后使用的索引可以与之前的索引顺序相连【index】
mysql> explain select name,money,test from test where name='1' and test=10 order by money;
+----+------+-----------------+-----------------+---------+-------+------+----------+--------------------------+
| id | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra                    |
+----+------+-----------------+-----------------+---------+-------+------+----------+--------------------------+
|  1 | ref  | name_money_test | name_money_test | 23      | const |    5 |    10.00 | Using where; Using index |
+----+------+-----------------+-----------------+---------+-------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
--不符合最佳左前缀【filesort】
mysql> explain select name,money,test from test order by name,test;
+----+-------+---------------+-----------------+---------+------+------+----------+----------------------------+
| id | type  | possible_keys | key             | key_len | ref  | rows | filtered | Extra                      |
+----+-------+---------------+-----------------+---------+------+------+----------+----------------------------+
|  1 | index | NULL          | name_money_test | 51      | NULL |   12 |   100.00 | Using index; Using filesort|
+----+-------+---------------+-----------------+---------+------+------+----------+----------------------------+
1 row in set, 1 warning (0.00 sec)


--同升同降测试，仅适用于覆盖索引
--同升同降【index】
mysql> explain select name,money,test from test order by name,money,test;
+----+-------------+---------+------------------+---------+------+------+----------+----------------+
| id | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra          |
+----+-------------+---------+------------------+---------+------+------+----------+----------------+
|  1 | index | NULL          | name_money_test  | 51      | NULL |   12 |   100.00 | Using index    |
+----+-------------+---------+------------------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
--不同升同降【filesort】
mysql> explain select name,money,test from test order by name,money,test desc;
+----+-------------+---------+------------------+---------+------+------+----------+---------------------------+
| id | type  | possible_keys | key              | key_len | ref  | rows | filtered | Extra                     |
+----+-------------+---------+------------------+---------+------+------+----------+---------------------------+
|  1 | index | NULL          | name_money_test  | 51      | NULL |   12 |  100.00  |Using index;Using filesort |
+----+-------------+---------+------------------+---------+------+------+----------+---------------------------+
1 row in set, 1 warning (0.00 sec)
```

（3）查询时**小表驱动大表**，让得出数据小的一方先执行。

```sql
--当A表的数据大时，sql的编写如下
select * from A where id in (select id from b)

select * from A a where exists (select 1 from B b where a.id = b.id )
```

（4）关联查询时，左连接时索引加右表，右连接时索引加左表

#### 3.存储引擎

​	数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。

##### 1.聚簇索引和非聚簇索引

​	聚簇索引并不是一种单独的索引类型，而是一种**数据存储方式**，聚簇索引和非聚簇索引底层的数据结构都是B+树。不同的是聚簇索引的叶子节点中**存储了索引和数据**（表中的一行），而非聚簇索引的叶子节点**只存储索引**，数据则需要到对应索引指向的数据文件中查找。

###### 1.聚簇索引

​	聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。

###### 2.非聚簇索引

​	非聚簇索引又称辅助索引，二级索引，叶子节点中存放的是索引值和索引对应数据的物理地址。每张表可以有多个非聚簇索引

###### 3.应用

​	InnoDB的主键索引为聚簇索引。

​	InnoDB的辅助键索引和MyIsam的主键索引、辅助键索引均为非聚簇索引。

###### 3.对比

- 聚簇索引查询数据时只需要一次IO，非聚簇索引的查询时由于数据的物理位置可能是凌乱的，所以会发生多次IO。
- 聚簇索引更加有利于范围查找和排序查找
- 聚簇索引的叶子节点中存储数据，当数据变化时只需要维护主键索引的数据，无须维护辅助索引。

##### 2.InnoDB

​	在InnoDB中，文件分为**表结构文件 **  (.frm) 和**表数据文件**  (.ibd) ，而**表数据文件本身就是按B+Tree组织的一个索引结构**，这棵树的叶子节点data域保存了完整的数据记录。

​	InnoDB的主键索引为聚簇索引，辅助键索引为非聚簇索引。辅助索引查询数据时，需要进行**二次查询**（根据辅助索引中所查到的主键值再次查询主键索引，找到所查数据）。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200815205153427.png" alt="image-20200815205153427" style="zoom:50%;" />

​	InnoDB的插入速度严重依赖于插入顺序，按照主键的**顺序插入**是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，定义一个**自增的ID列为主键**是最好的选择。

##### 3.MyIsam

​	在MyIsam中，文件分为**表结构文件 **  (.frm) 、**存储表数据文件**  (.myd) 和**存储表索引文件**（.myi）。索引和数据是分离的，索引中保存的是指向数据文件的指针。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200815210550679.png" alt="image-20200815210550679" style="zoom:50%;" />

​	与InnoDB的二次查找不同，MyIsam的辅助索引查找数据时和主键索引没有什么区别，也可根据存储的主键值直接查找对应的数据。不同的**只是主键索引要求key是唯一的，而辅助索引的key可以重复**

##### 4.Memory

​	Memory将数据**存储在内存**中，文件中只存储表的结构，内部使用的**Hash索引**，查询单个数据时很快。因为是在内存中存储数据，如果内存出现异常就会影响数据，如果重启或者关机所有数据都会消失。

##### 5.对比

|          | InnoDB                       | MyIsam                   |
| -------- | ---------------------------- | ------------------------ |
| 事务     | 支持                         | 不支持                   |
| 锁       | 行锁（索引失效时行锁变表锁） | 表锁                     |
| 外键     | 支持                         | 不支持                   |
| 主键     | 不设置自动生成6个字节的主键  | 允许没有                 |
| 备份     | 支持热备份，崩溃后可恢复     | 冷备份，不可安全恢复     |
| 存储空间 | 需要空间大                   | 支持压缩表，磁盘占用较小 |
| 并发     | MVCC保证高并发               | 并发差                   |

#### 4.日志

##### 1.bin log

​	归档日志。用于主从复制，在主从复制中，从数据库到主数据库的bin log进行重播，实现主从同步

##### 2.redo log

​	重做日志。确保事务的持久性，当写入发生故障时，重启MySQL后，会根据redo log进行重做

##### 3.undo log

​	回滚日志。保存事务发生前的上一版本的数据，用于回滚，同时提供MVCC下的读操作

#### 5.主从复制

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200815213853055.png" alt="image-20200815213853055" style="zoom:50%;" />

#### 6.读写分离

​	可根据主从复制实现MySQL的读写分离操作。从服务器负责读操作，主服务器负责写操作和实时性较强的读操作。读写分离可以**缓解数据库的锁竞争，提高并发**，根据不同的需求还可**更改数据库的存储引擎（从服务器可用MyIsam）。**读写分离还可以适当**增加冗余，提高可用性**。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200815215214868.png" alt="image-20200815215214868" style="zoom:50%;" />

### 三：SQL

#### 1.语法

##### 查询相关

```sql
1. distinct --相同的值只出现一次，所有列的值都相同才算相同
2. limit--限制返回的行数，可以为两个参数，第一个为起始值，第二个为返回总行数
	--返回前5行
		select * from test limit 5;
		select * from test limit 0,5;
	--返回第3，4，5行
		select * from test limit 2,3;
3. between ... and/not between ... and --between 1 and 3 :查出1，2，3
4. and 的优先级高于 or ，可以用括号改变
5. like --模糊查询 
		--通配符： like 'DB_'    ：查询以DB开头的三个字符的字符串
    --			  like '%DB%'   ：查询包含DB的全部记录
    --				rlike '[^AB]' ：不以AB开头的任意字符串
6. --函数
	/*
		1.计算  		 avg() 会忽略null值 
		2.文本	  	 left(name,2) 将name列中从左开始截取两个字符
						 		right(name,2)将name列中从右开始截取两个字符
						 		LTRIM() 去除左边空格
						 		RTRIM() 去除右边空格
		3.数值处理		sin() cos() tan() sqrt() abs()  mod():取余
	*/
7. --分组			having：作用于分组后的组，从中选出合适的组 值为NULL的行会被单独分为一组
		select name,count(*) num from account group by name having num>1;
8. --连接
		--内连接：等值连接 inner join 可省略
		select * from test,account where test.id=account.id;
		select t1.id,t2.money from test t1,test t2 where t1.id=t2.money;--自连接
		--外连接(left join ,right join),mysql 不支持全外连接，可用union连接左连接和有连接得到
		select a.name,b.job from A a  left join B b on a.id=b.A_id --根据左表（A表）行数显示，B表可能有null
9. --组合查询 union ：取并集   intersect ：取交集   except ：取差集
		select * from test where id >2
		union 															--union 默认去除相同行，union all可保留相同行
		select * from test where money>100;
10.--视图
		视图是虚拟的表，本身不包含数据，无索引
		视图可以简化复杂sql，只是用实际表的一部分数据，只给用户访问视图的权限可以保证安全
```

##### 增删改

```sql
--增
	insert into 表名(字段1,字段2..) values(值1,值2…); 
--删
	delete from 表 where 条件;
--改
	update 表 set 字段=值 where 条件;
```

#### 2.题解

1.只用一个sql，将sex字段反转（有 f,m 两个值）

```sql
update test set sex=CHAR(ASCII(sex)^ASCII('f')^ASCII('m'));
```

2.查name列中重复的值

```sql
select name from test group by name having count(name)>2;
```

3.删除重复的邮件

```sql
delete from mail t1,mail t2 where t1.email=t2.email and t1.id>t2.id 
```

4.查找工资第二高的人

```sql
select(select distinct name from test order by salary DESC limit 1,1 ) result;
```

5.查询连续出现三次的数字

```sql
select distinct t1.num from test t1,test t2,test t3
where t1.id=t2.id-1 and t2.id=t3.id-1
and t1.num=t2.num and t2.num=t3.num;
```

6.将得分排序，并统计排名

```sql
select s1.name,count(distinct s2.score) 'rank' 
from test s1 inner join test s2
on s1.score<=s2.soore
group by s1.id,s1.score
order by s1.score desc;
```

