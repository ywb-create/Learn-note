# Socket与IO模型

### 引入

​	在网络中，客户端和服务端交互时，常常是两个计算机间应用进程的数据交互，而数据发送需要从应用层向下层层包装，之后通过物理设备发送到另一端后再层层解封装，直到数据传送到接收端的应用层，之后被特定的进程使用。而应用层是由计算机内的应用进程控制的，应用层以下则是由OS控制，所以数据传送时会涉及到**系统调用**。此时就需要一个机制来负责应用层和传输层的交互，这就是Socket的由来。Socket是在应用层和传输层之间的一个抽象层，Socket本质是编程接口(API)，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用以**实现进程在网络中通信**。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200801084338172.png" alt="image-20200801084338172" style="zoom:33%;" />

### 实现

​	Socket起源于Unix，由Unix/Linux中“一切皆文件”的思想加以实现，在创建Socket后，系统调用会返回一个文件描述符，之后对Socket的操作会转化为对文件描述符的操作，也就是对文件流的操作，基本的操作模式就是“打开open –> 读写write/read –> 关闭close”。

​	对于一次Socket通信来说，以接收举例，数据传输需要两个阶段，（1）准备阶段：等待从网络收到数据，并且在数据到达后，**复制数据到内核缓冲区**	（2）拷贝阶段：**从内核缓冲区复制数据到进程缓冲区**，以便进程处理。

​	在Linux下，Socket有五种I/O模型。

### IO模型

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200817171939717.png" alt="image-20200817171939717" style="zoom:33%;" />

#### 1.阻塞式I/O

​	在准备阶段和拷贝阶段用户进程都会阻塞。

#### 2.非阻塞式I/O

​	在准备阶段，当用户进程读取数据时，若数据还未准备好，OS会返回error，用户进程会轮询OS，直到数据准备完成。在拷贝阶段用户进程阻塞。

#### 3.I/O多路复用

​	在I/O多路复用模式下，进程不在自己监视连接，内核替用户进程监视数据是否准备好，等内核检测到数据准备好后，阻塞拷贝数据。I/O多路复用的优点是可以**在单线程的环境中同时监测多个文件描述符是否可以进行I/O操作**。在阻塞和非阻塞模式下，每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。而多路复用可以使单线程处理多个IO请求。相比于多进程和多线程技术，I/O 复用还不需要进程线程创建和切换的开销，系统开销更小。

​	I/O多路复用有三种实现方式：select、poll、epoll

##### 1.select

​	将待检测的描述符放在数组中，全部传给内核进行监听，内核监听之后会返回一个就绪描述符个数，并且修改了监听的事件值，以表示该事件就绪。之后内核会把修改后的数组拷贝给用户空间，用户空间只能通过遍历所有描述符来处理就绪的描述符，处理后再将描述符传给内核继续监听。

缺点：

（1）select只能监听少于1024个文件描述符

（2）select只有监听读、写、异常这三个事件

（3）select 在数组返回后，需要进行遍历来处理就绪的时间，时间复杂度为O(n)

##### 2.poll

​	poll本质上和select没有区别，单改进了两点，一是poll是基于链表来存储的，**没有了最大连接数的限制**，二是**增加了监听的事件**

##### 3.epoll

​	epoll主要有三个方法：

```c
//1.epoll_create会创建一个eventpoll结构体
int epoll_create(int size);
struct eventpoll {
  //红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，也就是epoll监控的事件【存储epoll_ctl传来的Socket】
  struct rb_root rbr;　　
  //双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件【就绪链表，存储就绪的文件描述符】　　
  struct list_head rdllist;　　
};


//2.ctl主要是对红黑树的操作，涉及添加监听描述符、删除被监听的描述符、修改被监听的描述符。在添加文件描述符时会对相应的文件描述符注册回调函数，当该描述符上有数据就绪时，自动调用回调函数将该描述符加入就绪链表中。
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);


//3.将已经准备好的存储于就绪链表里的数据返回给用户空间
int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);
```

​	epoll通过**改变数据结构**和**采用事件驱动**来避免轮询查看可读写事件【用户进程从时间复杂度为O(n)的轮询机制降低为现在的O(1)】这两个改进，大大提高了并发量。

###### LT与ET

​	epoll的两种工作方式：1.水平触发（LT）     2.边缘触发（ET） 
​	LT模式：若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中，一直进行处理。 
​	ET模式：就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 注意**ET模式只支持非阻塞的读写**，为了保证数据的完整性。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200818224223139.png" alt="image-20200818224223139" style="zoom:50%;" />

​	ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。 

#### 4.信号驱动式I/O

​	用户进程不在等待数据是否准备好，在数据准备阶段可以处理其他逻辑，在数据准备好后再进行阻塞拷贝

#### 5.异步I/O

​	用户进程I/O请求后处理其他逻辑，等数据阶段和拷贝阶段都完成后，内核在返回给进程，进程进行数据处理







