# Socket与IO模型

### 引入

​	在网络中，客户端和服务端交互时，常常是两个计算机间应用进程的数据交互，而数据发送需要从应用层向下层层包装，之后通过物理设备发送到另一端后再层层解封装，直到数据传送到接收端的应用层，之后被特定的进程使用。而应用层是由计算机内的应用进程控制的，应用层以下则是由OS控制，所以数据传送时会涉及到**系统调用**。此时就需要一个机制来负责应用层和传输层的交互，这就是Socket的由来。Socket是在应用层和传输层之间的一个抽象层，Socket本质是编程接口(API)，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用以**实现进程在网络中通信**。

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200801084338172.png" alt="image-20200801084338172" style="zoom:33%;" />

### 实现

​	Socket起源于Unix，由Unix/Linux中“一切皆文件”的思想加以实现，在创建Socket后，系统调用会返回一个文件描述符，之后对Socket的操作会转化为对文件描述符的操作，也就是对文件流的操作，基本的操作模式就是“打开open –> 读写write/read –> 关闭close”。

​	对于一次Socket通信来说，以接收举例，数据传输需要两个阶段，（1）准备阶段：等待从网络收到数据，并且在数据到达后，**复制数据到内核缓冲区**	（2）拷贝阶段：**从内核缓冲区复制数据到进程缓冲区**，以便进程处理。

​	在Linux下，Socket有五种I/O模型。

### IO模型

<img src="https://github.com/ywb-create/Learn-note/blob/master/img/image-20200817171939717.png" alt="image-20200817171939717" style="zoom:33%;" />

#### 1.阻塞式I/O

​	在准备阶段和拷贝阶段用户进程都会阻塞。

#### 2.非阻塞式I/O

​	在准备阶段，当用户进程读取数据时，若数据还未准备好，OS会返回error，用户进程会轮询OS，直到数据准备完成。在拷贝阶段用户进程阻塞。

#### 3.I/O多路复用

​	在I/O多路复用模式下，进程不在自己监视连接，内核替用户进程监视数据是否准备好，等内核检测到数据准备好后，阻塞拷贝数据。I/O多路复用的优点是可以**在单线程的环境中同时监测多个文件描述符是否可以进行I/O操作**。在阻塞和非阻塞模式下，每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。而多路复用可以使单线程处理多个IO请求。相比于多进程和多线程技术，I/O 复用还不需要进程线程创建和切换的开销，系统开销更小。

​	I/O多路复用有三种实现方式：select、poll、epoll

##### 1.select

​	将每个文件描述符拷贝到内核态中，调用select()阻塞等待数据到来，轮询所有文件描述符，当发现一个文件描述符的数据准备好后，select()返回给用户进程。

缺点：

（1）select只能监听少于1024个文件描述符

（2）有用户态到内核态的开销

（3）select 是通过轮询的方式来查找文件描述符是否可读或者可写，时间复杂度为O(n)

##### 2.poll

​	poll本质上和select没有区别，但是它**没有最大连接数的限制**，原因是它是基于链表来存储的。

##### 3.epoll

​	用户态和内核态共享一块内存，l没有了从用户态到内核态拷贝的开销。并且当某个文件描述符的数据准备好后，会使用回调函数将就绪的文件描述符添加到就绪链表中，将准备好的数据返回，此方式的时间复杂度为O(1)。

​	epoll的两种工作方式：1.水平触发（LT）     2.边缘触发（ET） 
​	LT模式：若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中，一直进行处理。 
​	ET模式：就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 注意**ET模式只支持非阻塞的读写**，为了保证数据的完整性。
​	由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。 

#### 4.信号驱动式I/O

​	用户进程不在等待数据是否准备好，在数据准备阶段可以处理其他逻辑，在数据准备好后再进行阻塞拷贝

#### 5.异步I/O

​	用户进程I/O请求后处理其他逻辑，等数据阶段和拷贝阶段都完成后，内核在返回给进程，进程进行数据处理







